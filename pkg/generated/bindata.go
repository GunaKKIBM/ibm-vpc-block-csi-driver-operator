// Code generated for package generated by go-bindata DO NOT EDIT. (@generated)
// sources:
// assets/configmap.yaml
// assets/controller.yaml
// assets/controller_sa.yaml
// assets/csidriver.yaml
// assets/node.yaml
// assets/node_sa.yaml
// assets/rbac/attacher_role.yaml
// assets/rbac/attacher_rolebinding.yaml
// assets/rbac/provisioner_binding.yaml
// assets/rbac/provisioner_role.yaml
// assets/rbac/registrar_binding.yaml
// assets/rbac/registrar_role.yaml
// assets/storageclass/vpc-block-10iopsTier-StorageClass.yaml
// assets/storageclass/vpc-block-5iopsTier-StorageClass.yaml
// assets/storageclass/vpc-block-custom-StorageClass.yaml
package generated

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

// Name return file name
func (fi bindataFileInfo) Name() string {
	return fi.name
}

// Size return file size
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}

// Mode return file mode
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}

// Mode return file modify time
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}

// IsDir return file whether a directory
func (fi bindataFileInfo) IsDir() bool {
	return fi.mode&os.ModeDir != 0
}

// Sys return file is sys mode
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _configmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: ibm-vpc-block-csi-configmap
  namespace: openshift-cluster-csi-drivers
data:
  CSI_ENDPOINT: unix:/csi/csi.sock
  IKS_BLOCK_PROVIDER_NAME: iks-vpc
  IKS_ENABLED: "False"
  SECRET_CONFIG_PATH: /etc/storage_ibmc
  VPC_API_GENERATION: "1"
  VPC_API_TIMEOUT: 180s
  VPC_API_VERSION: "2019-07-02"
  VPC_BLOCK_PROVIDER_NAME: vpc
  VPC_ENABLED: "True"
  VPC_RETRY_ATTEMPT: "10"
  VPC_RETRY_INTERVAL: "120"`)

func configmapYamlBytes() ([]byte, error) {
	return _configmapYaml, nil
}

func configmapYaml() (*asset, error) {
	bytes, err := configmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _controllerYaml = []byte(`apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: ibm-vpc-block-csi-controller
  namespace: openshift-cluster-csi-drivers
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ibm-vpc-block-csi-driver
  template:
    metadata:
      labels:
        app: ibm-vpc-block-csi-driver
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000160009
      containers:
        - args:
            - --v=5
            - --csi-address=$(ADDRESS)
            - --timeout=600s
            - --feature-gates=Topology=true
          env:
            - name: ADDRESS
              value: /csi/csi.sock
          image: ${PROVISIONER_IMAGE}
          securityContext:
            privileged: false
            allowPrivilegeEscalation: false
          imagePullPolicy: Always
          name: csi-provisioner
          resources:
            limits:
              cpu: 100m
              memory: 100Mi
            requests:
              cpu: 10m
              memory: 20Mi
          volumeMounts:
            - mountPath: /csi
              name: socket-dir
        - args:
            - --v=5
            - --csi-address=/csi/csi.sock
            - --timeout=900s
          image: ${ATTACHER_IMAGE}
          securityContext:
            privileged: false
            allowPrivilegeEscalation: false
          imagePullPolicy: Always
          name: csi-attacher
          resources:
            limits:
              cpu: 100m
              memory: 100Mi
            requests:
              cpu: 10m
              memory: 20Mi
          volumeMounts:
            - mountPath: /csi
              name: socket-dir
        - args:
            - --csi-address=/csi/csi.sock
          image: ${LIVENESS_PROBE_IMAGE}
          name: liveness-probe
          securityContext:
            privileged: false
            allowPrivilegeEscalation: false
          resources:
            limits:
              cpu: 50m
              memory: 50Mi
            requests:
              cpu: 5m
              memory: 10Mi
          volumeMounts:
            - mountPath: /csi
              name: socket-dir
        - args:
            - --v=5
            - --endpoint=$(CSI_ENDPOINT)
            - --lock_enabled=false
          env:
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          envFrom:
            - configMapRef:
                name: ibm-vpc-block-csi-configmap
          image: ${DRIVER_IMAGE}
          imagePullPolicy: Always
          securityContext:
            privileged: false
            allowPrivilegeEscalation: false
          livenessProbe:
            failureThreshold: 5
            httpGet:
              path: /healthz
              port: healthz
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 3
          name: iks-vpc-block-driver
          ports:
            - containerPort: 9808
              name: healthz
              protocol: TCP
          resources:
            limits:
              cpu: 500m
              memory: 500Mi
            requests:
              cpu: 50m
              memory: 100Mi
          volumeMounts:
            - mountPath: /csi
              name: socket-dir
            - mountPath: /etc/storage_ibmc
              name: customer-auth
              readOnly: true
            - mountPath: /etc/storage_ibmc/cluster_info
              name: cluster-info
              readOnly: true
      serviceAccountName: ibm-vpc-block-controller-sa
      volumes:
        - emptyDir: {}
          name: socket-dir
        - name: customer-auth
          secret:
            secretName: storage-secret-store
        - configMap:
            name: cluster-info
          name: cluster-info
`)

func controllerYamlBytes() ([]byte, error) {
	return _controllerYaml, nil
}

func controllerYaml() (*asset, error) {
	bytes, err := controllerYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "controller.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _controller_saYaml = []byte(`apiVersion: v1
imagePullSecrets:
  - name: kube-system-icr-io
  - name: bluemix-default-secret
  - name: bluemix-default-secret-regional
  - name: bluemix-default-secret-international
  - name: icr-io-secret
kind: ServiceAccount
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: ibm-vpc-block-controller-sa
  namespace: openshift-cluster-csi-drivers
`)

func controller_saYamlBytes() ([]byte, error) {
	return _controller_saYaml, nil
}

func controller_saYaml() (*asset, error) {
	bytes, err := controller_saYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "controller_sa.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _csidriverYaml = []byte(`apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: vpc.block.csi.ibm.io
spec:
  attachRequired: true
  podInfoOnMount: true
  volumeLifecycleModes:
    - Persistent
`)

func csidriverYamlBytes() ([]byte, error) {
	return _csidriverYaml, nil
}

func csidriverYaml() (*asset, error) {
	bytes, err := csidriverYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "csidriver.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _nodeYaml = []byte(`apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: ibm-vpc-block-csi-node
  namespace: openshift-cluster-csi-drivers
spec:
  selector:
    matchLabels:
      app: ibm-vpc-block-csi-driver
  template:
    metadata:
      labels:
        app: ibm-vpc-block-csi-driver
    spec:
      containers:
        - args:
            - --v=5
            - --csi-address=$(ADDRESS)
            - --kubelet-registration-path=$(DRIVER_REGISTRATION_SOCK)
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: DRIVER_REGISTRATION_SOCK
              value: /var/lib/kubelet/plugins/vpc.block.csi.ibm.io/csi.sock
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          image: ${NODE_DRIVER_REGISTRAR_IMAGE}
          imagePullPolicy: Always
          lifecycle:
            preStop:
              exec:
                command:
                  - /bin/sh
                  - -c
                  - rm -rf /registration/vpc.block.csi.ibm.io /registration/vpc.block.csi.ibm.io-reg.sock
          name: csi-driver-registrar
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            privileged: false
          resources:
            limits:
              cpu: 100m
              memory: 100Mi
            requests:
              cpu: 10m
              memory: 20Mi
          volumeMounts:
            - mountPath: /csi
              name: plugin-dir
            - mountPath: /registration
              name: registration-dir
        - args:
            - --v=5
            - --endpoint=unix:/csi/csi.sock
          env:
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          envFrom:
            - configMapRef:
                name: ibm-vpc-block-csi-configmap
          image: ${DRIVER_IMAGE}
          imagePullPolicy: Always
          livenessProbe:
            failureThreshold: 5
            httpGet:
              path: /healthz
              port: healthz
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 3
          name: iks-vpc-block-node-driver
          ports:
            - containerPort: 9808
              name: healthz
              protocol: TCP
          resources:
            limits:
              cpu: 200m
              memory: 250Mi
            requests:
              cpu: 20m
              memory: 50Mi
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            privileged: true
          volumeMounts:
            - mountPath: /var/lib/kubelet
              mountPropagation: Bidirectional
              name: kubelet-data-dir
            - mountPath: /csi
              name: plugin-dir
            - mountPath: /dev
              name: device-dir
            - mountPath: /etc/udev
              name: etcudevpath
            - mountPath: /run/udev
              name: runudevpath
            - mountPath: /lib/udev
              name: libudevpath
            - mountPath: /sys
              name: syspath
            - mountPath: /etc/storage_ibmc
              name: customer-auth
              readOnly: true
            - mountPath: /etc/storage_ibmc/cluster_info
              name: cluster-info
              readOnly: true
        - args:
            - --csi-address=/csi/csi.sock
          image: ${LIVENESS_PROBE_IMAGE}
          name: liveness-probe
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            privileged: false
          resources:
            limits:
              cpu: 50m
              memory: 50Mi
            requests:
              cpu: 5m
              memory: 10Mi
          volumeMounts:
            - mountPath: /csi
              name: plugin-dir
      serviceAccountName: ibm-vpc-block-node-sa
      tolerations:
        - operator: Exists
      volumes:
        - hostPath:
            path: /var/lib/kubelet/plugins_registry/
            type: Directory
          name: registration-dir
        - hostPath:
            path: /var/lib/kubelet
            type: Directory
          name: kubelet-data-dir
        - hostPath:
            path: /var/lib/kubelet/plugins/vpc.block.csi.ibm.io/
            type: DirectoryOrCreate
          name: plugin-dir
        - hostPath:
            path: /dev
            type: Directory
          name: device-dir
        - hostPath:
            path: /etc/udev
            type: Directory
          name: etcudevpath
        - hostPath:
            path: /run/udev
            type: Directory
          name: runudevpath
        - hostPath:
            path: /lib/udev
            type: Directory
          name: libudevpath
        - hostPath:
            path: /sys
            type: Directory
          name: syspath
        - name: customer-auth
          secret:
            secretName: storage-secret-store
        - configMap:
            name: cluster-info
          name: cluster-info`)

func nodeYamlBytes() ([]byte, error) {
	return _nodeYaml, nil
}

func nodeYaml() (*asset, error) {
	bytes, err := nodeYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "node.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _node_saYaml = []byte(`apiVersion: v1
imagePullSecrets:
  - name: kube-system-icr-io
  - name: bluemix-default-secret
  - name: bluemix-default-secret-regional
  - name: bluemix-default-secret-international
  - name: icr-io-secret
kind: ServiceAccount
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: ibm-vpc-block-node-sa
  namespace: openshift-cluster-csi-drivers
`)

func node_saYamlBytes() ([]byte, error) {
	return _node_saYaml, nil
}

func node_saYaml() (*asset, error) {
	bytes, err := node_saYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "node_sa.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _rbacAttacher_roleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: vpc-block-external-attacher-role
rules:
  - apiGroups:
      - ""
    resources:
      - persistentvolumes
    verbs:
      - get
      - list
      - watch
      - update
      - patch
  - apiGroups:
      - ""
    resources:
      - nodes
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - csi.storage.k8s.io
    resources:
      - csinodeinfos
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - storage.k8s.io
    resources:
      - volumeattachments
    verbs:
      - get
      - list
      - watch
      - update
      - patch
`)

func rbacAttacher_roleYamlBytes() ([]byte, error) {
	return _rbacAttacher_roleYaml, nil
}

func rbacAttacher_roleYaml() (*asset, error) {
	bytes, err := rbacAttacher_roleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "rbac/attacher_role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _rbacAttacher_rolebindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: vpc-block-external-attacher-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vpc-block-external-attacher-role
subjects:
  - kind: ServiceAccount
    name: ibm-vpc-block-controller-sa
    namespace: openshift-cluster-csi-drivers
`)

func rbacAttacher_rolebindingYamlBytes() ([]byte, error) {
	return _rbacAttacher_rolebindingYaml, nil
}

func rbacAttacher_rolebindingYaml() (*asset, error) {
	bytes, err := rbacAttacher_rolebindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "rbac/attacher_rolebinding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _rbacProvisioner_bindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: vpc-block-provisioner-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vpc-block-provisioner-role
subjects:
  - kind: ServiceAccount
    name: ibm-vpc-block-controller-sa
    namespace: openshift-cluster-csi-drivers
`)

func rbacProvisioner_bindingYamlBytes() ([]byte, error) {
	return _rbacProvisioner_bindingYaml, nil
}

func rbacProvisioner_bindingYaml() (*asset, error) {
	bytes, err := rbacProvisioner_bindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "rbac/provisioner_binding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _rbacProvisioner_roleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: vpc-block-provisioner-role
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - get
      - list
  - apiGroups:
      - ""
    resources:
      - persistentvolumes
    verbs:
      - get
      - list
      - watch
      - create
      - delete
  - apiGroups:
      - ""
    resources:
      - persistentvolumeclaims
    verbs:
      - get
      - list
      - watch
      - update
  - apiGroups:
      - storage.k8s.io
    resources:
      - storageclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - list
      - watch
      - create
      - update
      - patch
  - apiGroups:
      - snapshot.storage.k8s.io
    resources:
      - volumesnapshots
    verbs:
      - get
      - list
  - apiGroups:
      - snapshot.storage.k8s.io
    resources:
      - volumesnapshotcontents
    verbs:
      - get
      - list
  - apiGroups:
      - storage.k8s.io
    resources:
      - csinodes
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - nodes
    verbs:
      - get
      - list
      - watch
`)

func rbacProvisioner_roleYamlBytes() ([]byte, error) {
	return _rbacProvisioner_roleYaml, nil
}

func rbacProvisioner_roleYaml() (*asset, error) {
	bytes, err := rbacProvisioner_roleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "rbac/provisioner_role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _rbacRegistrar_bindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: vpc-block-driver-registrar-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vpc-block-driver-registrar-role
subjects:
  - kind: ServiceAccount
    name: ibm-vpc-block-node-sa
    namespace: openshift-cluster-csi-drivers
`)

func rbacRegistrar_bindingYamlBytes() ([]byte, error) {
	return _rbacRegistrar_bindingYaml, nil
}

func rbacRegistrar_bindingYaml() (*asset, error) {
	bytes, err := rbacRegistrar_bindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "rbac/registrar_binding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _rbacRegistrar_roleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
  name: vpc-block-driver-registrar-role
rules:
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
  - apiGroups:
      - ""
    resources:
      - nodes
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - persistentvolumes
    verbs:
      - get
      - list
      - watch
      - create
      - delete
  - apiGroups:
      - ""
    resources:
      - persistentvolumeclaims
    verbs:
      - get
      - list
      - watch
      - update
  - apiGroups:
      - security.openshift.io
    resourceNames:
      - privileged
    resources:
      - securitycontextconstraints
    verbs:
      - use`)

func rbacRegistrar_roleYamlBytes() ([]byte, error) {
	return _rbacRegistrar_roleYaml, nil
}

func rbacRegistrar_roleYaml() (*asset, error) {
	bytes, err := rbacRegistrar_roleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "rbac/registrar_role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _storageclassVpcBlock10iopstierStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    storageclass.beta.kubernetes.io/is-default-class: "true"
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
    razee/force-apply: "true"
  name: ibmc-vpc-block-10iops-tier
parameters:
  billingType: hourly
  classVersion: "1"
  csi.storage.k8s.io/fstype: ext4
  encrypted: "false"
  encryptionKey: ""
  profile: 10iops-tier
  region: ""
  resourceGroup: ""
  sizeRange: '[10-2000]GiB'
  tags: ""
  zone: ""
provisioner: vpc.block.csi.ibm.io
reclaimPolicy: Delete

`)

func storageclassVpcBlock10iopstierStorageclassYamlBytes() ([]byte, error) {
	return _storageclassVpcBlock10iopstierStorageclassYaml, nil
}

func storageclassVpcBlock10iopstierStorageclassYaml() (*asset, error) {
	bytes, err := storageclassVpcBlock10iopstierStorageclassYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "storageclass/vpc-block-10iopsTier-StorageClass.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _storageclassVpcBlock5iopstierStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
    razee/force-apply: "true"
  name: ibmc-vpc-block-5iops-tier
parameters:
  billingType: hourly
  classVersion: "1"
  csi.storage.k8s.io/fstype: ext4
  encrypted: "false"
  encryptionKey: ""
  profile: 5iops-tier
  region: ""
  resourceGroup: ""
  sizeRange: '[10-2000]GiB'
  tags: ""
  zone: ""
provisioner: vpc.block.csi.ibm.io
reclaimPolicy: Delete
`)

func storageclassVpcBlock5iopstierStorageclassYamlBytes() ([]byte, error) {
	return _storageclassVpcBlock5iopstierStorageclassYaml, nil
}

func storageclassVpcBlock5iopstierStorageclassYaml() (*asset, error) {
	bytes, err := storageclassVpcBlock5iopstierStorageclassYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "storageclass/vpc-block-5iopsTier-StorageClass.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _storageclassVpcBlockCustomStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    version: 2.0.3_354
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    app: ibm-vpc-block-csi-driver
    razee/force-apply: "true"
  name: ibmc-vpc-block-custom
parameters:
  billingType: hourly
  classVersion: "1"
  csi.storage.k8s.io/fstype: ext4
  encrypted: "false"
  encryptionKey: ""
  iops: "400"
  profile: custom
  region: ""
  resourceGroup: ""
  sizeIOPSRange: |-
    [10-39]GiB:[100-1000]
    [40-79]GiB:[100-2000]
    [80-99]GiB:[100-4000]
    [100-499]GiB:[100-6000]
    [500-999]GiB:[100-10000]
    [1000-1999]GiB:[100-20000]
  sizeRange: '[10-2000]GiB'
  tags: ""
  zone: ""
provisioner: vpc.block.csi.ibm.io
reclaimPolicy: Delete
`)

func storageclassVpcBlockCustomStorageclassYamlBytes() ([]byte, error) {
	return _storageclassVpcBlockCustomStorageclassYaml, nil
}

func storageclassVpcBlockCustomStorageclassYaml() (*asset, error) {
	bytes, err := storageclassVpcBlockCustomStorageclassYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "storageclass/vpc-block-custom-StorageClass.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"configmap.yaml":                 configmapYaml,
	"controller.yaml":                controllerYaml,
	"controller_sa.yaml":             controller_saYaml,
	"csidriver.yaml":                 csidriverYaml,
	"node.yaml":                      nodeYaml,
	"node_sa.yaml":                   node_saYaml,
	"rbac/attacher_role.yaml":        rbacAttacher_roleYaml,
	"rbac/attacher_rolebinding.yaml": rbacAttacher_rolebindingYaml,
	"rbac/provisioner_binding.yaml":  rbacProvisioner_bindingYaml,
	"rbac/provisioner_role.yaml":     rbacProvisioner_roleYaml,
	"rbac/registrar_binding.yaml":    rbacRegistrar_bindingYaml,
	"rbac/registrar_role.yaml":       rbacRegistrar_roleYaml,
	"storageclass/vpc-block-10iopsTier-StorageClass.yaml": storageclassVpcBlock10iopstierStorageclassYaml,
	"storageclass/vpc-block-5iopsTier-StorageClass.yaml":  storageclassVpcBlock5iopstierStorageclassYaml,
	"storageclass/vpc-block-custom-StorageClass.yaml":     storageclassVpcBlockCustomStorageclassYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"configmap.yaml":     {configmapYaml, map[string]*bintree{}},
	"controller.yaml":    {controllerYaml, map[string]*bintree{}},
	"controller_sa.yaml": {controller_saYaml, map[string]*bintree{}},
	"csidriver.yaml":     {csidriverYaml, map[string]*bintree{}},
	"node.yaml":          {nodeYaml, map[string]*bintree{}},
	"node_sa.yaml":       {node_saYaml, map[string]*bintree{}},
	"rbac": {nil, map[string]*bintree{
		"attacher_role.yaml":        {rbacAttacher_roleYaml, map[string]*bintree{}},
		"attacher_rolebinding.yaml": {rbacAttacher_rolebindingYaml, map[string]*bintree{}},
		"provisioner_binding.yaml":  {rbacProvisioner_bindingYaml, map[string]*bintree{}},
		"provisioner_role.yaml":     {rbacProvisioner_roleYaml, map[string]*bintree{}},
		"registrar_binding.yaml":    {rbacRegistrar_bindingYaml, map[string]*bintree{}},
		"registrar_role.yaml":       {rbacRegistrar_roleYaml, map[string]*bintree{}},
	}},
	"storageclass": {nil, map[string]*bintree{
		"vpc-block-10iopsTier-StorageClass.yaml": {storageclassVpcBlock10iopstierStorageclassYaml, map[string]*bintree{}},
		"vpc-block-5iopsTier-StorageClass.yaml":  {storageclassVpcBlock5iopstierStorageclassYaml, map[string]*bintree{}},
		"vpc-block-custom-StorageClass.yaml":     {storageclassVpcBlockCustomStorageclassYaml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
